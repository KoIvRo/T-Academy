import json
import sys
from pathlib import Path
from typing import List, Any

import psycopg2

DB_DSN = {
    "dbname": "testdb",
    "user": "test",
    "password": "test",
    "host": "localhost",
    "port": 5432,
}

"""
CI checker for student SQL solutions.

Assumptions:
- Run from project root (where folders tests/, scripts/, student_solutions/ are).
- tests/*.json were generated by your generator and each test JSON contains:
    - test_id (e.g. "001")
    - alias (e.g. "old_clients")
    - order_matters (bool, optional, default True)
    - data_templates: list of SQL templates with placeholders like {{name1}}
    - cases: list of objects with:
        - case_id (optional)
        - params: dict mapping placeholders -> values
        - expected: list of expected rows (each expected row is a list)
- Student solution files are named: student_solutions/{test_id}_{alias}.sql
- scripts/ contains: hardCleanUp.sql, setup.sql, cleanup.sql
"""

# ---------- Paths config ----------
BASE_DIR = Path.cwd()
SCRIPTS_DIR = BASE_DIR / "scripts"
TESTS_DIR = SCRIPTS_DIR / "tests"
SOLUTIONS_DIR = BASE_DIR / "student_solutions"


# Helper to run a SQL and return rows or []
def execute(conn, query: str) -> List[Any]:
    if not query or not query.strip():
        return []
    with conn.cursor() as cur:
        cur.execute(query)
        if cur.description:
            return cur.fetchall()
        conn.commit()
        return []


from datetime import date
from decimal import Decimal


# Normalize rows to list-of-lists for deterministic comparison and pretty-print
def normalize_rows(rows):
    if rows is None:
        return []
    norm = []
    for r in rows:
        row = []
        for v in r:
            if isinstance(v, date):
                row.append(v.isoformat())  # 'YYYY-MM-DD' ÑÑ‚Ñ€Ğ¾ĞºĞ°
            elif isinstance(v, Decimal):
                row.append(float(v))  # Ñ‡Ğ¸ÑĞ»Ğ¾
            else:
                row.append(v)
        norm.append(row)
    return norm


# Substitute placeholders in a template using params dict:
# replaces {{key}} with SQL literal (quoted for strings)
def fill_template(template: str, params: dict) -> str:
    stmt = template
    for k, v in params.items():
        placeholder = "{{" + k + "}}"
        # Basic quoting for strings; numbers/bools left unquoted
        if isinstance(v, str):
            # Ğ•ÑĞ»Ğ¸ ÑÑ‚Ñ€Ğ¾ĞºĞ° ÑƒĞ¶Ğµ Ğ² ĞºĞ°Ğ²Ñ‹Ñ‡ĞºĞ°Ñ…, Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ
            if v.startswith("'") and v.endswith("'"):
                replacement = v
            else:
                replacement = "'" + v.replace("'", "''") + "'"
        elif v is None:
            replacement = "NULL"
        else:
            replacement = str(v)
        stmt = stmt.replace(placeholder, replacement)
    return stmt


def load_sql_file(path: Path) -> str:
    if not path.exists():
        return ""
    return path.read_text(encoding="utf-8")


def main():
    # Basic path checks
    if not SCRIPTS_DIR.exists():
        print(f"ERROR: scripts/ directory not found at {SCRIPTS_DIR}")
        sys.exit(2)
    if not TESTS_DIR.exists():
        print(f"ERROR: tests/ directory not found at {TESTS_DIR}")
        sys.exit(2)
    if not SOLUTIONS_DIR.exists():
        print(f"ERROR: student_solutions/ directory not found at {SOLUTIONS_DIR}")
        sys.exit(2)

    # Read scripts
    hard_cleanup_sql = load_sql_file(SCRIPTS_DIR / "hardCleanUp.sql") or load_sql_file(SCRIPTS_DIR / "hardCleanup.sql")
    setup_sql = load_sql_file(SCRIPTS_DIR / "setup.sql")
    cleanup_sql = load_sql_file(SCRIPTS_DIR / "cleanup.sql") or load_sql_file(SCRIPTS_DIR / "cleanUp.sql")

    if not hard_cleanup_sql:
        print("WARNING: hardCleanUp.sql is empty or missing, continuing without hard reset.")
    if not setup_sql:
        print("WARNING: setup.sql is empty or missing.")
    if not cleanup_sql:
        print("WARNING: cleanup.sql is empty or missing; tests will not clean DB between cases.")

    # Connect
    try:
        conn = psycopg2.connect(**DB_DSN)
    except Exception as e:
        print(f"ERROR: cannot connect to DB: {e}")
        sys.exit(2)
    conn.autocommit = True

    print("ğŸš€ CI checker start")

    # 1) Full reset then setup
    if hard_cleanup_sql:
        print("ğŸ§¹ Running hardCleanUp.sql")
        try:
            execute(conn, hard_cleanup_sql)
        except Exception as e:
            print(f"ERROR executing hardCleanUp.sql: {e}")
            conn.close()
            sys.exit(2)

    if setup_sql:
        print("ğŸ§± Running setup.sql")
        try:
            execute(conn, setup_sql)
        except Exception as e:
            print(f"ERROR executing setup.sql: {e}")
            conn.close()
            sys.exit(2)

    # Gather test files
    test_files = sorted(TESTS_DIR.glob("*.json"))
    if not test_files:
        print("No test JSON files found in tests/ â€” nothing to do.")
        conn.close()
        sys.exit(0)

    total_tests = 0
    passed_tests = 0
    failed_tests = 0

    # For more detailed output about failed cases
    detailed_failures = []

    for tf in test_files:
        try:
            test = json.loads(tf.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"ERROR reading test file {tf.name}: {e}")
            continue

        test_id = test.get("test_id") or test.get("id") or tf.stem
        alias = test.get("alias") or test.get("description", tf.stem)
        order_matters = test.get("order_matters", True)
        data_templates = test.get("data_templates") or test.get("data_template") or []
        cases = test.get("cases") or []

        print(f"\nğŸ“˜ Test {test_id} â€” {alias} (cases: {len(cases)})")
        total_tests += 1

        # student solution filename per agreed pattern:
        student_file = SOLUTIONS_DIR / f"{test_id}_{alias}.sql"
        if not student_file.exists():
            print(f"âŒ FAIL: student solution file not found: {student_file.name}")
            failed_tests += 1
            detailed_failures.append({
                "test_id": test_id,
                "alias": alias,
                "reason": "student file missing",
                "file": str(student_file)
            })
            continue

        student_sql = student_file.read_text(encoding="utf-8").strip()
        if not student_sql:
            print(f"âŒ FAIL: student solution file is empty: {student_file.name}")
            failed_tests += 1
            detailed_failures.append({
                "test_id": test_id,
                "alias": alias,
                "reason": "student file empty",
                "file": str(student_file)
            })
            continue

        test_ok = True
        for idx, case in enumerate(cases, start=1):
            print(f"  â–¶ Case {idx}... ", end="", flush=True)

            # Always global cleanup before preparing case to ensure deterministic state
            if cleanup_sql:
                try:
                    execute(conn, cleanup_sql)
                except Exception as e:
                    print(f"\nERROR executing cleanup before case: {e}")
                    test_ok = False
                    break

            # Build and run data statements for this case using data_templates + case["params"]
            params = case.get("params", {})
            try:
                for tmpl in data_templates:
                    stmt = fill_template(tmpl, params)
                    execute(conn, stmt)
            except Exception as e:
                print(f"\nâŒ ERROR preparing data for case {idx}: {e}")
                test_ok = False
                detailed_failures.append({
                    "test_id": test_id,
                    "alias": alias,
                    "case": idx,
                    "reason": "data preparation error",
                    "error": str(e)
                })
                break

            # Run student's SQL and fetch result
            try:
                student_result = execute(conn, student_sql) or []
            except Exception as e:
                print("âŒ Error executing student SQL")
                test_ok = False
                detailed_failures.append({
                    "test_id": test_id,
                    "alias": alias,
                    "case": idx,
                    "reason": "student_sql_error",
                    "error": str(e)
                })
                print(f"\n   Execution error: {e}")
                # cleanup after failing case to leave DB clean for next test
                if cleanup_sql:
                    execute(conn, cleanup_sql)
                break

            # expected in JSON may be stored as lists-of-lists or lists-of-tuples; normalize both
            expected_raw = case.get("expected") or case.get("expected_result") or []
            student_norm = normalize_rows(student_result)
            expected_norm = normalize_rows(expected_raw)

            # Compare
            if order_matters:
                match = (student_norm == expected_norm)
            else:
                match = (sorted(student_norm) == sorted(expected_norm))

            if match:
                print("âœ…")
            else:
                print("âŒ")
                test_ok = False
                failed_tests += 1
                detailed_failures.append({
                    "test_id": test_id,
                    "alias": alias,
                    "case": idx,
                    "reason": "mismatch",
                    "expected": expected_norm,
                    "actual": student_norm,
                    "order_matters": order_matters
                })
                # Print details for CI log
                print(f"     Expected: {expected_norm}")
                print(f"     Actual:   {student_norm}")

            # cleanup after each case (global cleanup)
            if cleanup_sql:
                execute(conn, cleanup_sql)

        if test_ok:
            print(f"âœ… Test {test_id} â€” all cases passed")
            passed_tests += 1
        else:
            print(f"âŒ Test {test_id} â€” some cases failed")
            # failed_tests incremented per case above; ensure at least one
            if not any(f['test_id'] == test_id for f in detailed_failures):
                failed_tests += 1

    # Final summary
    print("\nğŸ“Š SUMMARY")
    print(f"  Tests found: {len(test_files)}")
    print(f"  Tests passed (all cases): {passed_tests}")
    print(f"  Tests failed: {failed_tests}")

    if detailed_failures:
        print("\nğŸ§¾ Detailed failures:")
        for f in detailed_failures:
            tid = f.get("test_id")
            alias = f.get("alias")
            case = f.get("case")
            reason = f.get("reason")
            print(f" - {tid} / {alias} / case={case} : {reason}")
            if reason == "mismatch":
                print(f"    expected: {f.get('expected')}")
                print(f"    actual:   {f.get('actual')}")

    conn.close()

    # Exit code: non-zero if any failure
    if failed_tests > 0 or detailed_failures:
        print("\nâŒ CI CHECKER: finished with failures")
        sys.exit(1)
    else:
        print("\nâœ… CI CHECKER: all tests passed")
        sys.exit(0)


if __name__ == "__main__":
    main()
